2021.4.6:

0. Simulation类移到了automail包下，因为作业需求文档规定了入口类Simulation包含于automail包中。

1. 添加了ChargeCalculator静态工具类， 包含计算Cost的方法。该方法会从`automail.properties`文件中读入 per activity unit 和
Markup percentage 参数，并调用一次Modem模块取得不同楼层的ServiceFee，最后返回一个给定MailItem对象的Cost。方法会被MailPool和Robot共同调用。

MailPool调用是为了，当pool遇到机器人来取件时，pool会遍历池子里的所有邮件计算它们的Cost有没有超过Cost Threshold，如果超过，会把这个邮件
放到池子的邮件链表的头部，这样机器人就能优先取到了。

Robot调用是因为，不同楼层的serviceFee会随时变化，当送到客户手里的时候，机器人还要再调用ChargeCalculator类里的方法来确认最新的收费标准，
得到最新的cost，这样才能精确计费（并把计费结果打印出来）。

ChargeCalculator 的 WifiModem 是Simulation类里初始化的(老师整的)，通过setter设置到ChargeCalculator类里。

2. 因为最后投递结果是由MailItem打印的，所以在这个类里创建费用相关的属性，属性可以由ChargeCalculator类里的Cost计算方法修改（这个还没写）。

3. MailPool新建了一个空白方法，用于计算邮件们的cost，并把超出阈值的邮件提到链表前面去（提升了优先级）：

private void handlePriority(double chargeThreshold, LinkedList<Item> pool) {

		// travel all items in the pool, and calc the charge
		// if a item's charge exceeds threshold, move it to the head of the linked list
		// if not exceed, continue traveling

	}


2021.4.8:

0. 将路由器接口从ChargeCalculator移出，并放在了一个新类ModemAdapter， ModemAdapter类由Simulation类初始化成一个实例，包含该路由器的所有连接信息，并对外
提供查询API. ChargeCalculator的calcCharge方法将调用这个API实现Service fee 查询，查询产生的状态信息由ModemAdapter保存.
1. 将和Charge有关的参数（比如收费阈值之类的）从MailPool类中剥离开来并放到ChargeCalculator类中，减少了MailPool和Simulation的耦合(之前要从Simulation
获得收费阈值)，并提高了ChargeCalculator和MailPool的内聚。ChargeCalculator的所有和Charge计算有关的参数常量由Simulation类进行配置
2. 添加了MailItem的新的log打印方法,并添加了新的统计信息在Simulation结果打印中，可以根据设置Simulation的Charge_Display选择打印与否(作业要求)。
3. 在MailItem里添加了部分每份邮件各自的Charge信息。
4. 增加了一个查询结果类，结果类包含当前查询的尝试次数和任意类型的返回值。主要是为了取出当前的尝试次数方便而设立的。
5. 移动ChargeCalculator类到了simulation包下.

